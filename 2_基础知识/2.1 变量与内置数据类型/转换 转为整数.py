### 一、`int()` 转换的核心规则（总纲）
`int(x[, base])` 的核心作用是将输入 `x` 转换为**十进制整数**，转换规则分「基础规则」和「分场景详细规则」，覆盖所有合法输入类型，先明确核心前提：
- 可选参数 `base`：仅当 `x` 是**字符串**时生效，指定 `x` 的原始进制（范围 2~36），默认 `base=10`（十进制）；
- 转换失败时统一抛出 `ValueError`，核心原因是「输入格式不符合对应规则」。

---

### 二、分输入类型的详细转换规则
#### 场景1：输入 `x` 是「数字类型」（int/float/布尔值/复数）
##### 1.1 输入为整数（int）
- **规则**：直接返回原整数（无转换成本，仅做类型确认）；
- **示例**：
  ```python
  int(123) → 123  # 十进制整数直接返回
  int(-456) → -456  # 负数同样直接返回
  ```

##### 1.2 输入为浮点数（float）
- **规则**：**向零取整**（本质是截断小数部分，仅保留整数部分），既不是四舍五入，也不是向下取整；
- **关键注意**：
  - 正数：`int(3.999)` → 3（截断0.999），`int(5.0)` → 5（无小数直接返回）；
  - 负数：`int(-2.1)` → -2（仅截断小数0.1，不是-3），`int(-7.99)` → -7；
- **示例**：
  ```python
  print(int(3.9))   # 3
  print(int(-2.1))  # -2
  print(int(5.0))   # 5
  ```

##### 1.3 输入为布尔值（bool）
- **规则**：Python 中布尔值是整数的子类，固定映射：`True → 1`，`False → 0`；
- **示例**：
  ```python
  int(True) → 1
  int(False) → 0
  ```

##### 1.4 输入为复数（complex）
- **核心规则**：
  1. 直接调用 `int(复数)` 会抛出 `TypeError`，**无任何例外**（复数是不可直接转换为整数的数字类型）；
  2. 合法转换路径：需先提取复数的「实部（.real）」或「虚部（.imag）」（二者均返回 float 类型），再对提取的浮点数执行 `int()` 向零取整；
  3. 复数属性特性：`.real`/`.imag` 是复数对象的**只读属性**（非方法，取值时无括号），返回值永远是 float 类型（即使数值为整数，如 `5+0j` 的 `.real` 是 `5.0`）。
- **关键注意**：
  - 提取实部/虚部后，需严格遵循浮点数转整数的「向零取整」规则；
  - 仅当复数的虚部为 `0j` 时（如 `5+0j`），提取实部转整数的结果等价于直接转换该整数（`int(5.0)` → 5）。
- **示例1：直接转换复数（报错）**
  ```python
  comp_num = 2 + 3j
  try:
      int(comp_num)
  except TypeError as e:
      print(f"报错类型：{type(e)}，报错信息：{e}")  # 输出：<class 'TypeError'>，can't convert complex to int
  ```
- **示例2：提取实部转整数（合法路径）**
  ```python
  # 普通复数
  comp_num1 = 2.9 + 3.1j
  real_part1 = comp_num1.real  # 提取实部（float类型）
  real_int1 = int(real_part1)  # 浮点数向零取整
  print(f"复数 {comp_num1} 的实部：{real_part1} → 转整数：{real_int1}")  # 输出：2.9 → 2

  # 实部为整数的复数
  comp_num2 = 5 + 0j
  real_part2 = comp_num2.real  # 5.0（float类型）
  real_int2 = int(real_part2)
  print(f"复数 {comp_num2} 的实部：{real_part2} → 转整数：{real_int2}")  # 输出：5.0 → 5
  ```
- **示例3：提取虚部转整数（合法路径）**
  ```python
  # 负数虚部的复数
  comp_num3 = -4.5 - 7.8j
  imag_part3 = comp_num3.imag  # -7.8（float类型）
  imag_int3 = int(imag_part3)  # 向零取整，截断小数0.8
  print(f"复数 {comp_num3} 的虚部：{imag_part3} → 转整数：{imag_int3}")  # 输出：-7.8 → -7

  # 虚部为整数的复数
  comp_num4 = 0 + 8j
  imag_part4 = comp_num4.imag  # 8.0（float类型）
  imag_int4 = int(imag_part4)
  print(f"复数 {comp_num4} 的虚部：{imag_part4} → 转整数：{imag_int4}")  # 输出：8.0 → 8
  ```

#### 场景2：输入 `x` 是「字符串」（核心复杂场景）
##### 2.1 核心前提
- 字符串必须是「对应进制的合法数字字符」，字符范围由 `base` 决定：
  - `base=2`（二进制）：仅允许 `0、1`；
  - `base=8`（八进制）：仅允许 `0~7`；
  - `base=10`（十进制）：仅允许 `0~9`（可带正负号，如 `"-123"`）；
  - `base=16`（十六进制）：允许 `0~9、a~f、A~F`（大小写通用）；
  - `base>10`：超过10的数字用 `a~z/A~Z` 表示（如 `base=16` 中 `a=10`，`base=36` 中 `z=35`）。

##### 2.2 详细规则
1. **允许的格式**：
   - 可带**前导/后置空白**（如 `"  123  "`、`"\t456\n"`），会自动忽略；
   - 可带**正负号**（`+`/`-`），必须在字符串开头（空白后）；
   - 进制标识前缀可选（如二进制 `"0b101"`、八进制 `"0o10"`、十六进制 `"0x1a"`），前缀需与 `base` 匹配（如 `base=2` 时 `"0b101"` 合法，`base=10` 时 `"0b101"` 非法）。
2. **禁止的格式**：
   - 含非对应进制的字符（如 `base=2` 时 `"102"` 含 `2`，直接报错）；
   - 多个正负号（如 `"++123"`、`"-+456"`）；
   - 进制前缀与 `base` 不匹配（如 `base=10` 时 `"0x1a"` 报错）；
   - 空字符串/仅空白字符串（如 `""`、`"   "`）。

##### 2.3 示例（覆盖合法/非法场景）
```python
# 合法场景
int("123") → 123  # base默认10，纯数字字符串
int("  -456  ") → -456  # 带空白+负号
int("0b101", base=2) → 5  # 二进制前缀+base匹配
int("1a", base=16) → 26  # 十六进制（1*16 + 10 = 26）
int("z", base=36) → 35  # base=36，z对应35

# 非法场景（均报ValueError）
int("abc") → 报错（base=10，含非数字字符）
int("102", base=2) → 报错（二进制含2）
int("0x1a") → 报错（base=10，含十六进制前缀）
int("++123") → 报错（多个正号）
int("   ") → 报错（仅空白）
```

#### 场景3：输入 `x` 是「自定义对象」
- **规则**：对象需实现 `__int__()` 方法，`int()` 会调用该方法返回整数；若未实现，先调用 `__float__()` 再按浮点数规则转换；若均未实现，报错 `TypeError`；
- **示例**：
  ```python
  class MyNum:
      def __int__(self):
          return 100
  int(MyNum()) → 100  # 调用__int__方法

  class MyNum2:
      def __float__(self):
          return 3.9
  int(MyNum2()) → 3  # 先转浮点数再向零取整
  ```

---

### 三、关键易错点总结
1. 浮点数转整数是「向零取整（截断小数）」，不是四舍五入（`int(3.999)`≠4，`int(-2.9)`≠-3）；
2. `base` 参数仅对字符串生效，对数字类型无意义（如 `int(3.9, base=2)` 直接报错 `TypeError`）；
3. 字符串的进制前缀需与 `base` 匹配（如 `base=16` 时 `"1a"` 和 `"0x1a"` 都合法，`base=10` 时 `"0x1a"` 非法）；
4. 布尔值是整数子类，`int(True)`=1 是“类型兼容”，不是“转换”；
5. 复数不可直接转整数，必须先提取 `.real`/`.imag`（float 类型），再按浮点数规则转换，且 `.real`/`.imag` 是只读属性（无括号）。

---

### 四、规则速查表
| 输入类型   | 核心转换规则                                  | 允许的特殊格式                | 报错条件                          |
|------------|-----------------------------------------------|-----------------------------|-----------------------------------|
| 整数       | 直接返回原数                                  | 无                          | 无（本身就是int）                 |
| 浮点数     | 向零取整（截断小数部分）                      | 无                          | 无（所有float都可转，仅截断）     |
| 布尔值     | True→1，False→0                               | 无                          | 无                                |
| 字符串     | 按base解析为十进制整数，忽略首尾空白          | 首尾空白、开头±号、匹配的进制前缀 | 含非法字符/多符号/前缀不匹配/空串 |
| 自定义对象 | 调用__int__()，无则调__float__()再向零取整    | 无                          | 未实现__int__/__float__           |
| 复数       | 直接报错；需先提取.real/.imag（float）再向零取整 | 无（.real/.imag为只读属性） | 直接调用int(复数)抛TypeError      |